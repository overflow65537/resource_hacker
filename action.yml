name: 'Resource Hacker Icon Replacer'
description: 'Automatically download Resource Hacker and replace application icons'
author: 'overflow65537'

branding:
  icon: 'image'
  color: 'blue'

inputs:
  exe-path:
    description: 'Path to the executable file to modify'
    required: true
  icon-path:
    description: 'Path to the new icon file (.ico)'
    required: true
  output-path:
    description: 'Path for the output executable (optional, defaults to overwriting the input)'
    required: false
    default: ''
  resource-name:
    description: 'Resource name for the icon (default: MAINICON)'
    required: false
    default: 'MAINICON'
  resource-type:
    description: 'Resource type (default: ICONGROUP)'
    required: false
    default: 'ICONGROUP'
  resource-language:
    description: 'Resource language ID (default: 0 for neutral)'
    required: false
    default: '0'

outputs:
  output-file:
    description: 'Path to the modified executable file'
    value: ${{ steps.replace-icon.outputs.output-file }}

runs:
  using: 'composite'
  steps:
    - name: Download Resource Hacker
      shell: powershell
      run: |
        $ErrorActionPreference = 'Stop'
        Write-Host "üì• Downloading Resource Hacker from official website..."
        
        $downloadUrl = "https://angusj.com/resourcehacker/resource_hacker.zip"
        $tempZip = Join-Path $env:TEMP "resource_hacker.zip"
        $extractPath = Join-Path $env:TEMP "ResourceHacker"
        
        Write-Host "Download URL: $downloadUrl"
        Write-Host "Temp ZIP: $tempZip"
        Write-Host "Extract Path: $extractPath"
        
        # Download
        Invoke-WebRequest -Uri $downloadUrl -OutFile $tempZip -UseBasicParsing
        Write-Host "‚úÖ Download completed"
        
        # Extract
        Write-Host "üìÇ Extracting Resource Hacker..."
        if (Test-Path $extractPath) {
          Remove-Item -Path $extractPath -Recurse -Force
        }
        Expand-Archive -Path $tempZip -DestinationPath $extractPath -Force
        
        # Verify
        $rhExe = Get-ChildItem -Path $extractPath -Filter "ResourceHacker.exe" -Recurse | Select-Object -First 1
        if ($rhExe) {
          Write-Host "‚úÖ Resource Hacker extracted to: $($rhExe.FullName)"
          $rhDir = $rhExe.DirectoryName
          "RH_PATH=$rhDir" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        } else {
          Write-Error "‚ùå ResourceHacker.exe not found in extracted files"
          exit 1
        }
        
        # Cleanup
        Remove-Item -Path $tempZip -Force

    - name: Verify Input Files
      shell: powershell
      run: |
        Write-Host "üîç Verifying input files..."
        
        $exePath = "${{ inputs.exe-path }}"
        $iconPath = "${{ inputs.icon-path }}"
        
        if (-not (Test-Path $exePath)) {
          Write-Error "‚ùå Executable file not found: $exePath"
          exit 1
        }
        Write-Host "‚úÖ Found executable: $exePath"
        
        if (-not (Test-Path $iconPath)) {
          Write-Error "‚ùå Icon file not found: $iconPath"
          exit 1
        }
        Write-Host "‚úÖ Found icon: $iconPath"
        
        # Verify icon file is valid .ico
        if (-not $iconPath.EndsWith('.ico')) {
          Write-Warning "‚ö†Ô∏è  Icon file should have .ico extension"
        }

    - name: Replace Icon
      id: replace-icon
      shell: powershell
      run: |
        $exePath = "${{ inputs.exe-path }}"
        $iconPath = "${{ inputs.icon-path }}"
        $outputPath = "${{ inputs.output-path }}"
        $resourceName = "${{ inputs.resource-name }}"
        $resourceType = "${{ inputs.resource-type }}"
        $resourceLang = "${{ inputs.resource-language }}"
        
        # Determine output path
        if ([string]::IsNullOrWhiteSpace($outputPath)) {
          $outputPath = $exePath
          Write-Host "üìù Output will overwrite input file: $outputPath"
        } else {
          Write-Host "üìù Output will be saved to: $outputPath"
        }
        
        # Build resource mask
        $mask = "$resourceType,$resourceName,$resourceLang"
        
        # Build command
        $rhExe = Join-Path $env:RH_PATH "ResourceHacker.exe"
        
        Write-Host "üîß Replacing icon with Resource Hacker..."
        Write-Host "   Executable: $exePath"
        Write-Host "   Icon: $iconPath"
        Write-Host "   Resource Mask: $mask"
        
        # Execute Resource Hacker
        $logFile = "$env:TEMP\resourcehacker_log.txt"
        
        & $rhExe `
          -open $exePath `
          -save $outputPath `
          -action addoverwrite `
          -res $iconPath `
          -mask $mask `
          -log $logFile
        
        $exitCode = $LASTEXITCODE
        
        # Display log
        if (Test-Path $logFile) {
          Write-Host "`nüìã Resource Hacker Log:"
          Get-Content $logFile | ForEach-Object { Write-Host "   $_" }
        }
        
        # Check result
        if ($exitCode -ne 0) {
          Write-Error "‚ùå Resource Hacker failed with exit code: $exitCode"
          exit 1
        }
        
        if (-not (Test-Path $outputPath)) {
          Write-Error "‚ùå Output file was not created: $outputPath"
          exit 1
        }
        
        Write-Host "‚úÖ Icon replaced successfully!"
        Write-Host "üì¶ Output file: $outputPath"
        
        # Set output
        "output-file=$outputPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

    - name: Cleanup
      if: always()
      shell: powershell
      run: |
        Write-Host "üßπ Cleaning up temporary files..."
        $extractPath = Join-Path $env:TEMP "ResourceHacker"
        if (Test-Path $extractPath) {
          Remove-Item -Path $extractPath -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "‚úÖ Cleanup completed"
        }
